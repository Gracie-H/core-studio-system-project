<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>FlowField — Floating Scramble Tiles</title>
<style>
:root{ --bg1:#0a0f18; --bg2:#0c1222; --ink:#e9eeff; }
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%}
body{
  height:100%;
  background: radial-gradient(1100px 600px at 120% -10%, #b18cff10, transparent),
              linear-gradient(180deg, var(--bg1), var(--bg2) 60%);
  color:#e9eeff; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Arial;
  overflow:hidden;
}
#cv{position:fixed; inset:0; width:100%; height:100%; display:block; cursor:default}
#capture{
  position:fixed; right:12px; top:12px; z-index:10; cursor:pointer;
  background:#0e1528e6; color:#e9eeff; border:1px solid #ffffff33;
  border-radius:10px; padding:6px 10px; font-size:.85rem
}
.legend{
  position:fixed; left:12px; top:12px; z-index:9;
  color:#dfe6ff; font-size:.86rem; line-height:1.35;
  background:#0e1528cc; border:1px solid #ffffff24; border-radius:10px;
  padding:8px 10px; backdrop-filter:blur(6px)
}
.legend .muted{opacity:.72}
.legend .dot{display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:6px; transform:translateY(1px)}
.dot.a{background:#8be9fd} .dot.b{background:#baff29} .dot.c{background:#ff71b8}
.caption{
  position:fixed; left:12px; top:calc(12px + 92px); z-index:8; display:none;
  color:#c8d2f0; font-size:.8rem;
  background:#0e1528bf; border:1px solid #ffffff24; border-radius:10px;
  padding:6px 9px; backdrop-filter:blur(6px)
}
#toast{
  position:fixed; left:50%; transform:translateX(-50%); top:16px;
  background:#0e1528e6; border:1px solid #ffffff22;
  border-radius:10px; padding:6px 10px; font-size:.86rem; display:none
}

/* ==== floating tiles ==== */
#tiles {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 12;
}
.tile {
  position: absolute;
  background:#0e1528e6;
  border:1px solid #ffffff33;
  border-radius:12px;
  padding:8px 12px;
  font-size:.85rem;
  color:#e9eeff;
  max-width: 220px;
  box-shadow:0 2px 6px rgba(0,0,0,0.3);
  pointer-events: auto;
}
.tile .close {
  position:absolute; right:6px; top:4px; cursor:pointer; font-size:.9rem;
}
.tile .dot {
  position:absolute; right:6px; top:6px;
  width:12px; height:12px; border-radius:50%;
  background:#e64545;
}
.tile .title { font-weight:600; }
.tile .content { margin-top:6px; word-break:break-word; white-space:pre-wrap; }
</style>
</head>
<body>
<canvas id="cv"></canvas>
<button id="capture">CAPTURE</button>

<div class="legend" id="legend">
  <div><span class="dot a"></span><b>A</b> data-holders <span id="nA">0</span></div>
  <div><span class="dot b"></span><b>B</b> seen <span id="nB">0</span></div>
  <div><span class="dot c"></span><b>C</b> clicked <span id="nC">0</span></div>
  <div class="muted" style="margin-top:4px">
    overlaps: AB <span id="nAB">0</span> · AC <span id="nAC">0</span> · BC <span id="nBC">0</span> · ABC <span id="nABC">0</span>
  </div>
</div>

<div class="caption" id="caption">
  data-hold → exposure → response = closed loop (ABC glow = strongest capture)
</div>

<div id="toast"></div>
<div id="tiles"></div>

<script>
/* ================= data & parsing ================= */
let DATA = { A:new Set(), B:new Set(), C:new Set() };
let combos = {};
let density = 70, chaos = 40, glow = 85, tilt = 35;

const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');

/* sizes & DPR */
let W=0, H=0, DPR=1;
function resizeAll(){
  const rect = cv.getBoundingClientRect();
  DPR = Math.min(2, window.devicePixelRatio || 1);
  W = Math.floor(rect.width);
  H = Math.floor(rect.height);
  cv.width  = W * DPR;
  cv.height = H * DPR;
  ctx.setTransform(DPR,0,0,DPR,0,0);

  mask.width  = W * DPR;
  mask.height = H * DPR;
  mctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resizeAll);

/* persistent erase mask */
const mask = document.createElement('canvas');
const mctx = mask.getContext('2d');
function getCanvasPos(e){
  const r = cv.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top };
}
resizeAll();

/* drag & drop */
['dragenter','dragover','dragleave','drop'].forEach(ev=>window.addEventListener(ev,e=>e.preventDefault()));
window.addEventListener('drop', async e=>{
  const files = [...(e.dataTransfer?.files||[])];
  for(const f of files){
    const name = (f.name||'').toLowerCase();
    const json = JSON.parse(await f.text());
    if(name.includes('advertisers')) loadA(json);
    else if(name.includes('ads_viewed')) loadB(json);
    else if(name.includes('ads_clicked')) loadC(json);
  }
  rebuild(); toast('data loaded');
});

/* scramble text */
function randomChar(){
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789#@$%&*";
  return chars[Math.floor(Math.random()*chars.length)];
}
function scrambleText(el, finalText, duration=1500){
  let progress = 0;
  const length = finalText.length;
  const steps = Math.ceil(duration / 40);
  const timer = setInterval(()=>{
    progress++;
    let displayed = "";
    for(let i=0;i<length;i++){
      if(i < (progress/steps)*length){
        displayed += finalText[i];
      }else{
        displayed += randomChar();
      }
    }
    el.textContent = displayed;
    if(progress>=steps){ 
      clearInterval(timer);
      el.textContent = finalText;
    }
  },40);
}

/* floating tiles */
let tileCounter = 1;
let floatingTiles = [];

function spawnTiles(n=6, label="demo"){
  for(let i=0;i<n;i++){
    const container = document.getElementById("tiles");
    const tile = document.createElement("div");
    tile.className = "tile";

    const finalText = "##" + Math.random().toString(36).slice(2,8) + "##   " 
                    + "##" + Math.random().toString(36).slice(2,8) + "##";

    tile.innerHTML = `
      <span class="title">${label} · ${tileCounter++}</span>
      <span class="close">✕</span>
      <div class="dot"></div>
      <div class="content"></div>
    `;

    let contentEl = tile.querySelector(".content");
    scrambleText(contentEl, finalText, 1500);

    let x = Math.random() * (window.innerWidth-220);
    let y = Math.random() * (window.innerHeight-120);
    let vx = (Math.random()-0.5) * 1.2; 
    let vy = (Math.random()-0.5) * 1.2; 

    tile.style.left = x+"px";
    tile.style.top = y+"px";

    tile.querySelector(".close").onclick = ()=> {
      container.removeChild(tile);
      floatingTiles = floatingTiles.filter(t=>t.el!==tile);
    };

    container.appendChild(tile);
    floatingTiles.push({el:tile, x,y,vx,vy});
  }
}

function updateTiles(){
  for(const t of floatingTiles){
    t.x += t.vx;
    t.y += t.vy;
    if(t.x<0 || t.x>window.innerWidth-220) t.vx*=-1;
    if(t.y<0 || t.y>window.innerHeight-120) t.vy*=-1;
    t.el.style.left = t.x+"px";
    t.el.style.top = t.y+"px";
  }
  requestAnimationFrame(updateTiles);
}
updateTiles();

/* load data = spawn tiles */
function loadA(json){ DATA.A = new Set(extractStrings(json).filter(isBrandLike)); spawnTiles(6,"A"); }
function loadB(json){ DATA.B = new Set(parseAds(json).map(pickBrand).filter(Boolean)); spawnTiles(6,"B"); }
function loadC(json){ DATA.C = new Set(parseAds(json).map(pickBrand).filter(Boolean)); spawnTiles(6,"C"); }

/* helpers */
function extractStrings(obj, bucket=[]){
  if(!obj) return bucket;
  if(Array.isArray(obj)){ obj.forEach(x=>extractStrings(x,bucket)); return bucket; }
  if(typeof obj==='object'){
    for(const v of Object.values(obj)){
      if(typeof v==='string' || typeof v==='number'){
        const s=String(v); if(s.length>=2 && s.length<=80) bucket.push(s.trim());
      }else extractStrings(v,bucket);
    }
  }
  return bucket;
}
function parseAds(obj){
  const items=[];
  (function walk(o){
    if(!o) return;
    if(Array.isArray(o)){ o.forEach(walk); return; }
    if(typeof o==='object'){
      if(o.title && Array.isArray(o.string_list_data)){
        o.string_list_data.forEach(e => items.push({title:o.title, value:e.value, href:e.href}));
      }
      for(const v of Object.values(o)) walk(v);
    }
  })(obj);
  return items;
}
function isBrandLike(s){
  if(!s) return false;
  if(/https?:\/\/|@|\.json|true|false|null/i.test(s)) return false;
  return s.length>=2 && s.length<=60;
}
function domainFromHref(href){
  if(!href || typeof href!=='string') return null;
  let m = href.match(/https?:\/\/([^\/]+)\/?/); if(!m) return null;
  let host = m[1];
  if(host.includes('l.instagram.com')){
    const m2 = href.match(/[?&]u=([^&]+)/);
    if(m2){ try{
      const real = decodeURIComponent(m2[1]);
      const m3 = real.match(/https?:\/\/([^\/]+)\/?/); if(m3) host = m3[1];
    }catch{}}
  }
  return host.replace(/^www\./,'');
}
function canonicalize(s){
  s = (s||'').toLowerCase().trim()
    .replace(/[@#]/g,'').replace(/\.(com|co|net|org|io|ai)$/,'')
    .replace(/\b(official|inc|ltd|co|company|store|shop|the|global|online)\b/g,'')
    .replace(/[^a-z0-9]+/g,' ').replace(/\s+/g,' ').trim();
  return s;
}
function pickBrand(rec){
  const arr=[]; if(rec?.title) arr.push(rec.title); if(rec?.value) arr.push(rec.value);
  const d = domainFromHref(rec?.href); if(d) arr.push(d);
  for(const c of arr){ const s=c.trim(); if(isBrandLike(s)) return s; }
  return null;
}
function toMap(set){
  const out={}; for(const s of set){ const k=canonicalize(s); if(!k) continue; (out[k]||(out[k]=new Set())).add(s); }
  return out;
}
function inter(a,b){ const r=new Set(); a.forEach(x=>{ if(b.has(x)) r.add(x);}); return r; }
function union(a,b){ const r=new Set(a); b.forEach(x=>r.add(x)); return r; }
function diff(a,b){ const r=new Set(); a.forEach(x=>{ if(!b.has(x)) r.add(x);}); return r; }

function rebuild(){
  const A=toMap(DATA.A), B=toMap(DATA.B), C=toMap(DATA.C);
  const KA=new Set(Object.keys(A)), KB=new Set(Object.keys(B)), KC=new Set(Object.keys(C));
  combos = {
    A:[...diff(KA, union(KB,KC))], B:[...diff(KB, union(KA,KC))], C:[...diff(KC, union(KA,KB))],
    AB:[...diff(inter(KA,KB),KC)], AC:[...diff(inter(KA,KC),KB)], BC:[...diff(inter(KB,KC),KA)],
    ABC:[...inter(inter(KA,KB),KC)],
  };
  setText('nA', KA.size); setText('nB', KB.size); setText('nC', KC.size);
  setText('nAB', combos.AB.length); setText('nAC', combos.AC.length);
  setText('nBC', combos.BC.length); setText('nABC', combos.ABC.length);
  reseed();
}
function setText(id,v){ document.getElementById(id).textContent = v; }

/* ================= flow field ================= */
function Noise(seed=7){
  function rnd(){ seed=(seed*1664525+1013904223)>>>0; return seed/4294967296; }
  const gx=[], gy=[], S=256;
  for(let i=0;i<S;i++){ const a=rnd()*Math.PI*2; gx[i]=Math.cos(a); gy[i]=Math.sin(a); }
  function dot(ix,iy,x,y){ const idx=(ix+iy*57)&255; const dx=x-ix, dy=y-iy; return gx[idx]*dx + gy[idx]*dy; }
  function fade(t){ return t*t*(3-2*t); }
  return (x,y)=>{
    const x0=Math.floor(x), y0=Math.floor(y), x1=x0+1, y1=y0+1;
    const sx=fade(x-x0), sy=fade(y-y0);
    const n0=dot(x0,y0,x,y), n1=dot(x1,y0,x,y);
    const ix0=n0 + sx*(n1-n0);
    const n2=dot(x0,y1,x,y), n3=dot(x1,y1,x,y);
    const ix1=n2 + sx*(n3-n2);
    return (ix0 + sy*(ix1-ix0))*0.5 + 0.5;
  };
}
const noise = Noise(1337);

const MAX=6000; let pts=[], t=0;
const COLOR = {
  A:'rgba(139,233,253,0.11)', B:'rgba(186,255,41,0.09)', C:'rgba(255,113,184,0.11)',
  AB:'rgba(80,230,210,0.13)', AC:'rgba(190,170,255,0.13)', BC:'rgba(230,255,120,0.13)',
  ABC:'rgba(255,220,255,0.16)'
};
function weights(){
  const w={A:1,B:1,C:1,AB:2,AC:2,BC:2,ABC:4}, out={}, ks=Object.keys(w); let sum=0;
  ks.forEach(k=>{ const n=(combos[k]||[]).length; const v=Math.log10(n+1.5)*w[k]+(n>0?0.2:0); out[k]=Math.max(0,v); sum+=out[k]; });
  ks.forEach(k=> out[k]=sum? out[k]/sum : 1/ks.length); return out;
}
function pickType(){
  const w=weights(), order=["ABC","AB","AC","BC","A","B","C"]; const r=Math.random(); let acc=0;
  for(const k of order){ acc+=w[k]; if(r<=acc) return k; } return "A";
}
function spawn(){
  const typ=pickType(), ang=(tilt/100)*Math.PI + Math.random()*0.6 - 0.3;
  const rad=(0.12+Math.random()*0.55)*Math.min(W,H);
  const x=W*0.5 + Math.cos(ang)*rad, y=H*0.55 + Math.sin(ang)*rad;
  return {x,y,vx:(Math.random()-0.5)*0.2, vy:(Math.random()-0.5)*0.2, age:0, life:80+Math.random()*260, len:0, type:typ};
}
function reseed(){
  pts.length=0; const count=Math.min(MAX, density*50);
  for(let i=0;i<count;i++) pts.push(spawn());
}

/* erase */
let eraseMode=false, erasing=false, brushRadius=36;
cv.addEventListener('pointerdown', e=>{
  if(!eraseMode) return;
  erasing=true; const p=getCanvasPos(e); drawMask(p.x,p.y);
});
cv.addEventListener('pointermove', e=>{
  if(!eraseMode || !erasing) return;
  const p=getCanvasPos(e); drawMask(p.x,p.y);
});
window.addEventListener('pointerup', ()=> erasing=false);

function drawMask(x,y){
  mctx.save();
  mctx.globalCompositeOperation='source-over';
  mctx.fillStyle='rgba(255,255,255,1)';
  mctx.beginPath(); mctx.arc(x,y,brushRadius,0,Math.PI*2); mctx.fill();
  mctx.restore();
}

/* ================= loop ================= */
function frame(){
  t += 0.003 + chaos/100*0.005;

  // 背景渐隐
  ctx.globalCompositeOperation='source-over';
  ctx.fillStyle=`rgba(8,12,22,${0.08*(1-glow/100*0.6)})`;
  ctx.fillRect(0,0,W,H);

  // flow field 绘制
  ctx.globalCompositeOperation='lighter';
  for(const p of pts){
    const kx=0.003+chaos/100*0.004, ky=kx;
    const bias=({A:13,B:37,C:71,AB:103,AC:131,BC:167,ABC:199})[p.type]||0;
    const nx=noise(p.x*kx + bias, p.y*ky + t*0.5);
    const ny=noise(p.x*kx + t*0.3, p.y*ky + bias);
    const ang=(nx-0.5)*Math.PI*2.1 + (tilt/100)*0.6;
    const spd=(ny*0.9+0.1);
    p.vx += Math.cos(ang)*0.12*spd; 
    p.vy += Math.sin(ang)*0.12*spd;
    p.vx *= 0.96; p.vy *= 0.96;
    p.x+=p.vx; p.y+=p.vy; p.age++; 
    p.len=Math.min(1,p.len+0.08);

    // 边界循环
    if(p.x<-10) p.x=W+10; 
    if(p.x>W+10) p.x=-10; 
    if(p.y<-10) p.y=H+10; 
    if(p.y>H+10) p.y=-10;

    ctx.strokeStyle=COLOR[p.type]; 
    ctx.lineWidth=1.0 + ny*1.2; 
    ctx.globalAlpha=0.9;
    ctx.beginPath(); 
    ctx.moveTo(p.x,p.y); 
    ctx.lineTo(p.x-p.vx*6*p.len, p.y-p.vy*6*p.len); 
    ctx.stroke();

    if(p.age>p.life) Object.assign(p, spawn());
  }

  // 应用擦除 mask
  ctx.save();
  ctx.globalCompositeOperation = 'destination-out';
  ctx.drawImage(mask, 0, 0, W, H);
  ctx.restore();

  requestAnimationFrame(frame);
}
reseed(); frame();

/* ================= capture & keys ================= */
document.getElementById('capture').addEventListener('click', capturePNG);
window.addEventListener('keydown', e=>{
  if(e.key==='c' || e.key==='C'){ 
    capturePNG(); 
  } else if(e.key==='e' || e.key==='E'){
    eraseMode=!eraseMode;
    cv.style.cursor = eraseMode ? 'crosshair' : 'default';
    toast(`erase: ${eraseMode?'on':'off'}`);
  } else if(e.key==='i' || e.key==='I'){
    const el=document.getElementById('caption');
    el.style.display = (el.style.display==='block') ? 'none' : 'block';
  }
});

function capturePNG(){
  const a=document.createElement('a');
  a.download=`flowfield_${Date.now()}.png`;
  a.href=cv.toDataURL('image/png'); 
  a.click();
  toast('captured');
}
function toast(msg){
  const el=document.getElementById('toast'); 
  el.textContent=msg; 
  el.style.display='block';
  clearTimeout(el._t); 
  el._t=setTimeout(()=>el.style.display='none', 1200);
}
</script>
</body>
</html>
