<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>FlowField — Glitch · Erase · Tiles (with Red Dots)</title>
<style>
:root{ --bg1:#0a0f18; --bg2:#0c1222; --ink:#e9eeff; }
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%}
body{
  height:100%;
  background: radial-gradient(1100px 600px at 120% -10%, #b18cff10, transparent),
              linear-gradient(180deg, var(--bg1), var(--bg2) 60%);
  color:#e9eeff; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Arial;
  overflow:hidden;
}
#cv, #ov{position:fixed; inset:0; width:100%; height:100%; display:block}
#ov{pointer-events:none}
#capture{
  position:fixed; right:12px; top:12px; z-index:12; cursor:pointer;
  background:#0e1528e6; color:#e9eeff; border:1px solid #ffffff33;
  border-radius:10px; padding:6px 10px; font-size:.85rem
}
.controls{
  position:fixed; right:12px; top:56px; z-index:12; display:flex; flex-direction:column; gap:10px
}
.controls button{
  background:#0e1528cc; color:#e9eeff; border:1px solid #ffffff2a; border-radius:12px;
  padding:10px 14px; font-size:.9rem; cursor:pointer; box-shadow:0 4px 10px #0006
}
.legend{
  position:fixed; left:12px; top:12px; z-index:9;
  color:#dfe6ff; font-size:.9rem; line-height:1.35;
  background:#0e1528cc; border:1px solid #ffffff24; border-radius:12px;
  padding:10px 12px; backdrop-filter:blur(6px)
}
.legend .muted{opacity:.72}
.legend .dot{display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:6px; transform:translateY(1px)}
.dot.a{background:#8be9fd} .dot.b{background:#baff29} .dot.c{background:#ff71b8}
.legend .row{margin:3px 0}
.caption{
  position:fixed; left:12px; top:calc(12px + 140px); z-index:8; display:none;
  color:#c8d2f0; font-size:.8rem; background:#0e1528bf; border:1px solid #ffffff24; border-radius:10px;
  padding:6px 9px; backdrop-filter:blur(6px)
}
#toast{
  position:fixed; left:50%; transform:translateX(-50%); top:16px;
  background:#0e1528e6; border:1px solid #ffffff22; border-radius:10px; padding:6px 10px; font-size:.86rem; display:none; z-index:20
}
#tiles{ position:fixed; inset:0; pointer-events:none; z-index:11 }
.tile{ position:absolute; max-width:36ch; font-size:.82rem; line-height:1.25; color:#dfe6ff; pointer-events:auto;
  background:#0b1326e0; border:1px dashed #6b7bb833; border-radius:12px; padding:10px 12px; filter:drop-shadow(0 6px 12px #0008) }
.tile .hdr{font-size:.72rem; opacity:.7; margin-bottom:4px}
.tile .scr{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
.tile .x{ position:absolute; top:6px; right:24px; opacity:.75; cursor:pointer }
.tile .notif{ position:absolute; right:6px; top:6px; width:16px; height:16px; border-radius:50%; background:#ff3b30; box-shadow:0 0 0 2px #0b1326e0; cursor:pointer }
.tile .notif.blink{ animation:blink 1.2s infinite }
@keyframes blink{0%,60%{opacity:1} 80%{opacity:.25} 100%{opacity:1}}
#quote{position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:19; pointer-events:none; opacity:0; transition:.6s ease; font-size:14px; line-height:1.4; text-align:center; color:#dfe6ff; background:#0b1326cc; border:1px solid #ffffff2a; padding:10px 14px; border-radius:12px; max-width:min(72ch,86vw);}
#quote.show{opacity:1}
#selfies{position:fixed; inset:0; z-index:14; pointer-events:auto}
#selfies .echo{position:absolute; will-change:transform;}
#selfies .echo img{display:block; width:var(--size,80px); height:var(--size,80px); object-fit:cover; border:0px solid #ffffff26; box-shadow:0 6px 18px #0008}
.hint{ position:fixed; right:12px; bottom:12px; z-index:12; font-size:.78rem; opacity:.85; background:#0e1528cc; border:1px solid #ffffff24; padding:8px 10px; border-radius:10px }
</style>
</head>
<body>
<canvas id="cv"></canvas>
<canvas id="ov"></canvas>


<div class="controls">
  <button id="capture">Capture data（C）</button>
  <button id="glitchToggle">Activity Data (G)</button>
  <button id="eraseToggle">Erase Mode (E)</button>
  <button id="tilesSpawn">Spawn Photos (T)</button>

  <!-- 已按你的要求移除 Filter Bubble (B) 按钮与 Strength 滑块 -->
</div>

<div class="legend" id="legend">
  <div class="row"><span class="dot a"></span><b>A</b> data-holders <span id="nA">0</span></div>
  <div class="row"><span class="dot b"></span><b>B</b> seen <span id="nB">0</span></div>
  <div class="row"><span class="dot c"></span><b>C</b> clicked <span id="nC">0</span></div>
  <div class="muted" style="margin-top:6px">overlaps: AB <span id="nAB">0</span> · AC <span id="nAC">0</span> · BC <span id="nBC">0</span> · ABC <span id="nABC">0</span></div>
</div>

<div class="caption" id="caption">data-hold → exposure → response = closed loop (ABC glow = strongest capture)</div>
<div id="tiles"></div>
<div id="toast"></div>
<div id="quote">The blank spaces of deletion—what remains unseen is also part of me.</div>
<div id="selfies"></div>

<!-- <div class="hint">拖入 <b>.json</b>/<b>.txt</b> 生成卡片 · 点卡片右上<b>红点</b>触发乱码雨 · 按 <b>E</b> 擦拭 · 按 <b>B</b> 观察“过滤气泡”</div> -->

<script>

// 统一入口：一次交互要撒多少张，自己调
function triggerSpawnFromInteraction(count = 12){
  spawnPhotos(count);
  toast(`+${count} photos`);
}

  // 随机撒“222.jpg”照片（默认 12 张）
function spawnPhotos(total = 12){
  for(let i=0; i<total; i++){
    const size = Math.round(24 + Math.random()*50); // 24~164 px
    const x = Math.max(8, Math.random()*(W - size - 16));
    const y = Math.max(8, Math.random()*(H - size - 16));

    const fig = document.createElement('figure');
    fig.className = 'echo';
    fig.style.left = x + 'px';
    fig.style.top  = y + 'px';
    fig.style.setProperty('--size', size + 'px');
   

    const img = document.createElement('img');
    img.src = '222.jpg';     // 确保这张图和 html 放在同一目录
    img.alt = 'photo';
    fig.appendChild(img);
    selfies.appendChild(fig);

    // 简单拖拽
    let dragging=false, dx=0, dy=0;
    fig.addEventListener('pointerdown', e=>{
      dragging=true; dx=e.clientX-fig.offsetLeft; dy=e.clientY-fig.offsetTop;
      fig.setPointerCapture(e.pointerId);
    });
    fig.addEventListener('pointermove', e=>{
      if(!dragging) return;
      fig.style.left=(e.clientX-dx)+'px';
      fig.style.top =(e.clientY-dy)+'px';
    });
    fig.addEventListener('pointerup', e=>{
      dragging=false; fig.releasePointerCapture(e.pointerId);
    });
  }
}


/* 让擦除时禁用会拦截指针的浮层 */
function setErasePointerState(on){
  selfies.style.pointerEvents = on ? 'none' : 'auto';
  document.querySelectorAll('.tile, #selfies').forEach(el=>{
    el.style.pointerEvents = pe;
  });
}

/* ================= data & parsing ================= */
let DATA = { A:new Set(), B:new Set(), C:new Set() };
let combos = {};
let density = 70, chaos = 40, glow = 85, tilt = 35;

const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const ov = document.getElementById('ov');
const octx = ov.getContext('2d');
const tiles = document.getElementById('tiles');
const quoteEl = document.getElementById('quote');
const selfies = document.getElementById('selfies');

/* sizes & DPR */
let W=0, H=0, DPR=1;
function resizeAll(){
  const rect = cv.getBoundingClientRect();
  DPR = Math.min(2, window.devicePixelRatio || 1);
  W = Math.floor(rect.width);
  H = Math.floor(rect.height);
  cv.width  = W * DPR; cv.height = H * DPR; ctx.setTransform(DPR,0,0,DPR,0,0);
  ov.width  = W * DPR; ov.height = H * DPR; octx.setTransform(DPR,0,0,DPR,0,0);
  // sync erase mask
  mask.width  = W * DPR; mask.height = H * DPR; mctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resizeAll);

/* persistent erase mask (offscreen) */
const mask = document.createElement('canvas');
const mctx = mask.getContext('2d');

/* helper: pointer → canvas local (CSS px) */
function getCanvasPos(e){ const r = cv.getBoundingClientRect(); return { x: e.clientX - r.left, y: e.clientY - r.top }; }
resizeAll();

/* drag & drop */
['dragenter','dragover','dragleave','drop'].forEach(ev=>window.addEventListener(ev,e=>e.preventDefault()));
window.addEventListener('drop', async e=>{
  const files = [...(e.dataTransfer?.files||[])];
  for(const f of files){
    const name = (f.name||'').toLowerCase();
    if(name.endsWith('.txt')){ const text = await f.text(); spawnTilesFromText(text, f.name); continue; }
    if(!name.endsWith('.json')) continue;
    const json = JSON.parse(await f.text());
    if(name.includes('advertisers')) loadA(json);
    else if(name.includes('ads_viewed')) loadB(json);
    else if(name.includes('ads_clicked')) loadC(json);
    else { const strs = extractStrings(json).slice(0,200); spawnTilesFromList(strs, f.name); }
  }
  rebuild(); toast('data loaded');
});

function loadA(json){ DATA.A = new Set(extractStrings(json).filter(isBrandLike)); }
function loadB(json){ DATA.B = new Set(parseAds(json).map(pickBrand).filter(Boolean)); }
function loadC(json){ DATA.C = new Set(parseAds(json).map(pickBrand).filter(Boolean)); }

function extractStrings(obj, bucket=[]){
  if(!obj) return bucket;
  if(Array.isArray(obj)){ obj.forEach(x=>extractStrings(x,bucket)); return bucket; }
  if(typeof obj==='object'){
    for(const v of Object.values(obj)){
      if(typeof v==='string' || typeof v==='number'){
        const s=String(v); if(s.length>=2 && s.length<=80) bucket.push(s.trim());
      }else extractStrings(v,bucket);
    }
  }
  return bucket;
}
function parseAds(obj){
  const items=[];(function walk(o){ if(!o) return; if(Array.isArray(o)){ o.forEach(walk); return; } if(typeof o==='object'){ if(o.title && Array.isArray(o.string_list_data)){ o.string_list_data.forEach(e => items.push({title:o.title, value:e.value, href:e.href})); } for(const v of Object.values(o)) walk(v); } })(obj); return items;
}
function isBrandLike(s){ if(!s) return false; if(/https?:\/\/|@|\.json|true|false|null/i.test(s)) return false; return s.length>=2 && s.length<=60; }
function domainFromHref(href){ if(!href || typeof href!=='string') return null; let m = href.match(/https?:\/\/([^\/]+)\/?/); if(!m) return null; let host = m[1]; if(host.includes('l.instagram.com')){ const m2 = href.match(/[?&]u=([^&]+)/); if(m2){ try{ const real = decodeURIComponent(m2[1]); const m3 = real.match(/https?:\/\/([^\/]+)\/?/); if(m3) host = m3[1]; }catch{}} } return host.replace(/^www\./,''); }
function canonicalize(s){ s=(s||'').toLowerCase().trim().replace(/[@#]/g,'').replace(/\.(com|co|net|org|io|ai)$/,'').replace(/\b(official|inc|ltd|co|company|store|shop|the|global|online)\b/g,'').replace(/[^a-z0-9]+/g,' ').replace(/\s+/g,' ').trim(); return s; }
function pickBrand(rec){ const arr=[]; if(rec?.title) arr.push(rec.title); if(rec?.value) arr.push(rec.value); const d = domainFromHref(rec?.href); if(d) arr.push(d); for(const c of arr){ const s=c.trim(); if(isBrandLike(s)) return s; } return null; }
function toMap(set){ const out={}; for(const s of set){ const k=canonicalize(s); if(!k) continue; (out[k]||(out[k]=new Set())).add(s); } return out; }
function inter(a,b){ const r=new Set(); a.forEach(x=>{ if(b.has(x)) r.add(x);}); return r; }
function union(a,b){ const r=new Set(a); b.forEach(x=>r.add(x)); return r; }
function diff(a,b){ const r=new Set(); a.forEach(x=>{ if(!b.has(x)) r.add(x);}); return r; }

function rebuild(){
  const A=toMap(DATA.A), B=toMap(DATA.B), C=toMap(DATA.C);
  const KA=new Set(Object.keys(A)), KB=new Set(Object.keys(B)), KC=new Set(Object.keys(C));
  combos = {
    A:[...diff(KA, union(KB,KC))], B:[...diff(KB, union(KA,KC))], C:[...diff(KC, union(KA,KB))],
    AB:[...diff(inter(KA,KB),KC)], AC:[...diff(inter(KA,KC),KB)], BC:[...diff(inter(KB,KC),KA)],
    ABC:[...inter(inter(KA,KB),KC)],
  };
  setText('nA', KA.size); setText('nB', KB.size); setText('nC', KC.size);
  setText('nAB', combos.AB.length); setText('nAC', combos.AC.length); setText('nBC', combos.BC.length); setText('nABC', combos.ABC.length);
  reseed(); buildGlyphsFromCombos();
}
function setText(id,v){ document.getElementById(id).textContent = v; }

/* ================= flow field ================= */
function Noise(seed=7){
  function rnd(){ seed=(seed*1664525+1013904223)>>>0; return seed/4294967296; }
  const gx=[], gy=[], S=256;
  for(let i=0;i<S;i++){ const a=rnd()*Math.PI*2; gx[i]=Math.cos(a); gy[i]=Math.sin(a); }
  function dot(ix,iy,x,y){ const idx=(ix+iy*57)&255; const dx=x-ix, dy=y-iy; return gx[idx]*dx + gy[idx]*dy; }
  function fade(t){ return t*t*(3-2*t); }
  return (x,y)=>{
    const x0=Math.floor(x), y0=Math.floor(y), x1=x0+1, y1=y0+1;
    const sx=fade(x-x0), sy=fade(y-y0);
    const n0=dot(x0,y0,x,y), n1=dot(x1,y0,x,y);
    const ix0=n0 + sx*(n1-n0);
    const n2=dot(x0,y1,x,y), n3=dot(x1,y1,x,y);
    const ix1=n2 + sx*(n3-n2);
    return (ix0 + sy*(ix1-ix0))*0.5 + 0.5;
  };
}
const noise = Noise(1337);

const MAX=6000; let pts=[], t=0;
const COLOR = {
  A:'rgba(139,233,253,0.11)', B:'rgba(186,255,41,0.09)', C:'rgba(255,113,184,0.11)',
  AB:'rgba(80,230,210,0.13)', AC:'rgba(190,170,255,0.13)', BC:'rgba(230,255,120,0.13)',
  ABC:'rgba(255,220,255,0.16)'
};
function weights(){ const w={A:1,B:1,C:1,AB:2,AC:2,BC:2,ABC:4}, out={}, ks=Object.keys(w); let sum=0; ks.forEach(k=>{ const n=(combos[k]||[]).length; const v=Math.log10(n+1.5)*w[k]+(n>0?0.2:0); out[k]=Math.max(0,v); sum+=out[k]; }); ks.forEach(k=> out[k]=sum? out[k]/sum : 1/ks.length); return out; }
function pickType(){ const w=weights(), order=['ABC','AB','AC','BC','A','B','C']; const r=Math.random(); let acc=0; for(const k of order){ acc+=w[k]; if(r<=acc) return k; } return 'A'; }
function spawn(){ const typ=pickType(), ang=(tilt/100)*Math.PI + Math.random()*0.6 - 0.3; const rad=(0.12+Math.random()*0.55)*Math.min(W,H); const x=W*0.5 + Math.cos(ang)*rad, y=H*0.55 + Math.sin(ang)*rad; return {x,y,vx:(Math.random()-0.5)*0.2, vy:(Math.random()-0.5)*0.2, age:0, life:80+Math.random()*260, len:0, type:typ}; }
function reseed(){ pts.length=0; const count=Math.min(MAX, density*50); for(let i=0;i<count;i++) pts.push(spawn()); }

/* ================= persistent eraser ================= */
let eraseMode = false, erasing = false, brushRadius = 20;
let eraseCount = 0, selfieEnabled = false;

window.addEventListener('pointerdown', (e)=>{
  if(!eraseMode) return;
  e.preventDefault();
  erasing = true;
  eraseCount++;
  if(!selfieEnabled && eraseCount >= 15){ selfieEnabled = true; toast('Selfie mode unlocked'); }
  const p = getCanvasPos(e);
  drawMask(p.x, p.y);
});
window.addEventListener('pointermove', (e)=>{
  if(!eraseMode || !erasing) return;
  e.preventDefault();
  const p = getCanvasPos(e);
  drawMask(p.x, p.y);
});
window.addEventListener('pointerup', ()=>{ erasing = false; });

function drawMask(x, y){
  mctx.save();
  mctx.globalCompositeOperation = 'source-over';
  mctx.fillStyle = '#fff';
  mctx.beginPath();
  mctx.arc(x, y, brushRadius, 0, Math.PI * 2);
  mctx.fill();
  mctx.restore();
}
function applyMaskTo(ctx2){
  ctx2.save();
  ctx2.globalCompositeOperation = 'destination-out';
  ctx2.drawImage(mask, 0, 0, W * DPR, H * DPR, 0, 0, W, H);
  ctx2.restore();
}
function toggleErase(){
  eraseMode = !eraseMode;
  cv.style.cursor = eraseMode ? 'crosshair' : 'default';
  setErasePointerState(eraseMode);
  toast(`erase: ${eraseMode ? 'on' : 'off'}`);
}

/* ================= glitch / gibberish overlay ================= */
let glitchOn=false; let glyphCols=[]; let glitchBurst=0;
const GLYPHS_BASE = '01ABCDEFGHIJKLMNOPQRSTUVWXYZ#$%*+?<>/\\';
function buildGlyphsFromCombos(){
  const tokens = []; const pull = k=> (combos[k]||[]).slice(0,80).forEach(s=>tokens.push(s.toUpperCase())); ['ABC','AB','AC','BC','A','B','C'].forEach(pull);
  const flat = tokens.join(' '); const cleaned = flat.replace(/[^A-Z0-9#@$%&*+\-_/\\]/g,' ');
  const bank = (GLYPHS_BASE + ' ' + cleaned).split('').filter(Boolean);
  const nCols = Math.max(16, Math.floor(W/22));
  glyphCols = Array.from({length:nCols}, (_,i)=>({ x: Math.floor((i+0.5)*W/nCols), y: Math.random()*-H, speed: 1.2+Math.random()*2.6, len: 6 + Math.floor(Math.random()*22), charset: bank }));
}
function triggerGlitchBurst(){ glitchOn=true; buildGlyphsFromCombos(); glitchBurst = Math.max(glitchBurst, 240); flashQuote(); }
function flashQuote(){ quoteEl.classList.add('show'); clearTimeout(quoteEl._t); quoteEl._t = setTimeout(()=> quoteEl.classList.remove('show'), 1800); }
function drawGlitch(){
  if(!glitchOn){ octx.clearRect(0,0,W,H); return; }
  const boost = glitchBurst>0 ? 1.0 : 0.0;
  octx.fillStyle = `rgba(8,12,22,${0.05+0.10*boost})`;
  octx.fillRect(0,0,W,H);
  glyphCols.forEach(col=>{
    const spd = col.speed * (1 + 1.2*boost);
    const len = Math.round(col.len * (1 + 0.8*boost));
    for(let i=0;i<len;i++){
      const ch = col.charset[(Math.random()*col.charset.length)|0];
      const yy = col.y + i*18;
      const fade = i/len;
      const r = 120+fade*80, g = 200+fade*40, b = 255;
      octx.fillStyle = `rgba(${r},${g},${b},${0.2+0.7*(1-fade)})`;
      octx.save(); octx.translate(col.x, yy);
      octx.rotate(Math.sin(yy*0.01 + t*3)*0.1);
      octx.fillText(ch, 0, 0);
      octx.restore();
    }
    col.y += spd;
    if(col.y - len*18 > H) col.y = -Math.random()*H*0.5;
  });
  if(glitchBurst>0) glitchBurst--;
}

/* ============ Filter Bubble（保留功能；仅键盘 B 控制） ============ */
let filterOn = true;
// 滑块被删除，强度使用默认 0.60；若日后加回滑块，下面会自动读取
function getBubbleStrength(){ 
  const el = document.getElementById('bubbleStrength'); 
  return el ? (parseInt(el.value,10)||0)/100 : 0.6; 
}
function drawFilterBubble(){
  if(!filterOn) return;
  const s = getBubbleStrength(); // 0~1
  const cx = W*0.5, cy = H*0.5;
  const r = Math.max(120, Math.min(W,H) * (0.9 - s*0.7));
  octx.save();
  octx.globalCompositeOperation='source-over';
  const g = octx.createRadialGradient(cx, cy, r*0.6, cx, cy, r);
  g.addColorStop(0.0, 'rgba(14,21,40,0.00)');
  g.addColorStop(0.7, `rgba(14,21,40,${0.15 + s*0.20})`);
  g.addColorStop(1.0, `rgba(14,21,40,${0.35 + s*0.45})`);
  octx.fillStyle = g;
  octx.fillRect(0,0,W,H);
  octx.restore();
}

/* 键位 */
window.addEventListener('keydown', e=>{
  if(e.key==='b' || e.key==='B'){
    filterOn = !filterOn;
    toast(`filter bubble: ${filterOn?'on':'off'}`);
  }
});

/* ================= floating info tiles ================= */
const activeTiles = [];
function scrambleText(str, t){
  const base = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  return str.split('').map((ch,i)=>{
    if(/\s/.test(ch) || Math.random() < Math.min(0.25, (Math.sin(t*0.002+i*0.3)*0.5+0.5)*0.35)) return ch;
    return base[(Math.sin(t*0.01+i*7)*1000|0)%base.length] || '#';
  }).join('');
}
function makeTile(text, title='info'){
  const el = document.createElement('div');
  el.className='tile';
  el.style.left = (Math.random()*(W-260)+20)+'px';
  el.style.top = (Math.random()*(H-160)+20)+'px';
  el.innerHTML = `<div class="x" title="close">✕</div>
                  <div class="notif blink" title="new"></div>
                  <div class="hdr">${title}</div>
                  <div class="scr"></div>`;
  const scr = el.querySelector('.scr');
  const source = (text||'').slice(0,300);
  let alive=true; let t0=performance.now();
  (function loop(){ if(!alive) return; const t=performance.now()-t0; scr.textContent = scrambleText(source, t); requestAnimationFrame(loop); })();
  el.querySelector('.x').onclick=()=>{ 
    alive=false; el.remove(); 
    const i=activeTiles.findIndex(a=>a.el===el); if(i>-1) activeTiles.splice(i,1); 
  };
  el.querySelector('.notif').addEventListener('click', (e)=>{
  e.stopPropagation();
  triggerSpawnFromInteraction(6); // 想少一点就改数字，比如 6
});

  tiles.appendChild(el); 
  activeTiles.push({el, vx:(Math.random()-0.5)*0.6, vy:(Math.random()-0.5)*0.6});
  let dragging=false, dx=0, dy=0;
  el.addEventListener('pointerdown', e=>{ dragging=true; dx=e.clientX - el.offsetLeft; dy=e.clientY - el.offsetTop; el.setPointerCapture(e.pointerId); });
  el.addEventListener('pointermove', e=>{ if(!dragging) return; el.style.left=(e.clientX-dx)+'px'; el.style.top=(e.clientY-dy)+'px'; });
  el.addEventListener('pointerup', e=>{ dragging=false; el.releasePointerCapture(e.pointerId); });
}
function spawnTilesFromList(list, title){
  const pick = (arr,n)=>{ const out=[]; for(let i=0;i<n && arr.length;i++){ out.push(arr[(Math.random()*arr.length)|0]); } return out; };
  const lines = pick(list.filter(s=>s && s.trim().length>2), 6);
  lines.forEach((ln,i)=> makeTile(ln, title+' · '+(i+1)) );
}
function spawnTilesFromText(text, title){ const lines = text.split(/\n+/).map(s=>s.trim()).filter(Boolean); spawnTilesFromList(lines, title.replace(/\.[^.]+$/,'') ); }
function driftTiles(){
  activeTiles.forEach(a=>{
    const r=a.el.getBoundingClientRect();
    let x=r.left + a.vx, y=r.top + a.vy;
    if(x<8||x>W-r.width-8) a.vx*=-1;
    if(y<8||y>H-r.height-8) a.vy*=-1;
    a.el.style.left = Math.max(8, Math.min(W-r.width-8, x))+'px';
    a.el.style.top  = Math.max(8, Math.min(H-r.height-8, y))+'px';
  });
}

/* ================= loop ================= */
function frame(){
  t += 0.003 + chaos/100*0.005;

  // 背景拖影
  ctx.globalCompositeOperation='source-over';
  ctx.fillStyle=`rgba(8,12,22,${0.08*(1-glow/100*0.6)})`;
  ctx.fillRect(0,0,W,H);

  // 流线轨迹
  ctx.globalCompositeOperation='lighter';
  for(const p of pts){
    const kx=0.003+chaos/100*0.004, ky=kx;
    const bias=({A:13,B:37,C:71,AB:103,AC:131,BC:167,ABC:199})[p.type]||0;
    const nx=noise(p.x*kx + bias, p.y*ky + t*0.5);
    const ny=noise(p.x*kx + t*0.3, p.y*ky + bias);
    const ang=(nx-0.5)*Math.PI*2.1 + (tilt/100)*0.6;
    const spd=(ny*0.9+0.1);
    p.vx += Math.cos(ang)*0.12*spd; p.vy += Math.sin(ang)*0.12*spd;
    p.vx *= 0.96; p.vy *= 0.96;
    p.x+=p.vx; p.y+=p.vy; p.age++; p.len=Math.min(1,p.len+0.08);
    if(p.x<-10) p.x=W+10; if(p.x>W+10) p.x=-10; if(p.y<-10) p.y=H+10; if(p.y>H+10) p.y=-10;
    ctx.strokeStyle=COLOR[p.type]; ctx.lineWidth=1.0 + ny*1.2; ctx.globalAlpha=0.9;
    ctx.beginPath(); ctx.moveTo(p.x,p.y);
    ctx.lineTo(p.x-p.vx*6*p.len, p.y-p.vy*6*p.len); ctx.stroke();
    if(p.age>p.life) Object.assign(p, spawn());
  }

  // 乱码雨
  drawGlitch();

  // 过滤气泡（仍保留，键盘 B 控制）
  drawFilterBubble();

  // 漂浮卡片
  driftTiles();

  // 应用擦除 mask
  ctx.save();
  ctx.globalCompositeOperation = 'destination-out';
  ctx.drawImage(mask, 0, 0, W, H);
  ctx.restore();
  
  requestAnimationFrame(frame);
}
reseed(); buildGlyphsFromCombos(); frame();

/* ================= capture & keys ================= */
document.getElementById('capture').addEventListener('click', capturePNG);
window.addEventListener('keydown', e=>{
  if(e.key==='c' || e.key==='C'){ capturePNG(); }
  else if(e.key==='e' || e.key==='E'){ toggleErase(); }
  else if(e.key==='i' || e.key==='I'){ toggleCaption(); }
  else if(e.key==='g' || e.key==='G'){ glitchOn=!glitchOn; if(glitchOn) buildGlyphsFromCombos(); toast(`glitch: ${glitchOn?'on':'off'}`); }
  else if(e.key==='t' || e.key==='T'){ triggerSpawnFromInteraction(12); }
  else if(e.key==='b' || e.key==='B'){ filterOn=!filterOn; toast(`filter bubble: ${filterOn?'on':'off'}`); }
});

document.getElementById('glitchToggle').onclick=()=>{ glitchOn=!glitchOn; if(glitchOn) buildGlyphsFromCombos(); toast(`glitch: ${glitchOn?'on':'off'}`) };
document.getElementById('eraseToggle').onclick=()=>{ toggleErase(); };
document.getElementById('tilesSpawn').onclick=()=> triggerSpawnFromInteraction(12);



// 兼容：clearTiles 可能不存在
const clearBtn = document.getElementById('clearTiles');
if(clearBtn){ clearBtn.onclick=()=>{ tiles.innerHTML=''; activeTiles.length=0; }; }

// selfie spawning after 15 erases
cv.addEventListener('click', ()=>{ if(selfieEnabled) selfieCopyDistributed(5); });
function selfieCopyDistributed(total=8){
  for(let i=0;i<total;i++){
    const x = Math.random()*(W-160)+40; const y = Math.random()*(H-200)+40;
    const sizePx = Math.round(20 + Math.random()*140);
    const fig = document.createElement('figure'); fig.className='echo';
    fig.style.left=x+'px'; fig.style.top=y+'px'; fig.style.setProperty('--size', sizePx+'px');
    const img = document.createElement('img'); img.src='222.jpg'; img.alt='self clone';
    fig.appendChild(img); selfies.appendChild(fig);
    let dragging=false, dx=0, dy=0;
    fig.addEventListener('pointerdown', e=>{ dragging=true; dx=e.clientX-fig.offsetLeft; dy=e.clientY-fig.offsetTop; fig.setPointerCapture(e.pointerId); });
    fig.addEventListener('pointermove', e=>{ if(!dragging) return; fig.style.left=(e.clientX-dx)+'px'; fig.style.top=(e.clientY-dy)+'px'; });
    fig.addEventListener('pointerup', e=>{ dragging=false; fig.releasePointerCapture(e.pointerId); });
  }
}

function toggleCaption(){ const el=document.getElementById('caption'); el.style.display = (el.style.display==='block') ? 'none' : 'block'; }
function capturePNG(){
  const out = document.createElement('canvas');
  out.width = cv.width; out.height = cv.height;
  const octx2 = out.getContext('2d');
  octx2.drawImage(cv, 0, 0);
  octx2.drawImage(ov, 0, 0);
  
  const a=document.createElement('a');
  a.download=`flowfield_${Date.now()}.png`;
  a.href=out.toDataURL('image/png');
  a.click();
  toast('captured');
}
function toast(msg){
  const el=document.getElementById('toast');
  el.textContent=msg; el.style.display='block';
  clearTimeout(el._t); el._t=setTimeout(()=>el.style.display='none', 1200);
}

/* demo tiles from combos */
function demoSpawnTiles(){
  const buckets=['ABC','AB','AC','BC','A','B','C'];
  const got = [];
  buckets.forEach(k=> (combos[k]||[]).slice(0,4).forEach(v=>got.push(`[${k}] ${v}`)) );
  if(!got.length){
    const fill = ['algorithmic feed','opaque targeting','click-through flow','ad exposure chain','capture attention'];
    spawnTilesFromList(fill,'demo'); return;
  }
  spawnTilesFromList(got,'tokens');
}
</script>
</body>
</html>
